var search_data = {"index":{"searchIndex":["ackermann","ackermann_function()","define_new_result()","evaluate()","evaluate_special_case()","get_pending_array()","is_infinity?()","is_pending_result?()","is_previous_result?()","is_special_case?()","new()","return_previous_result()","select_nested_array()","store_new_pending_result()"],"longSearchIndex":["ackermann","ackermann#ackermann_function()","ackermann#define_new_result()","ackermann#evaluate()","ackermann#evaluate_special_case()","ackermann#get_pending_array()","ackermann#is_infinity?()","ackermann#is_pending_result?()","ackermann#is_previous_result?()","ackermann#is_special_case?()","ackermann::new()","ackermann#return_previous_result()","ackermann#select_nested_array()","ackermann#store_new_pending_result()"],"info":[["Ackermann","","Ackermann.html","","<p>The Ackermann class contain custom methods to implement the Ackermann\nfunction. As defined on wikipedia …\n"],["ackermann_function","Ackermann","Ackermann.html#method-i-ackermann_function","(m, n)","<p>The ackermann_function method is the brute force implementation of the\nackermann function The ackermann …\n"],["define_new_result","Ackermann","Ackermann.html#method-i-define_new_result","(nested_array_dimension, ackermann_index_array, new_result)","<p>The define_new_result method is intended to store a final new integer\nresult for a previously pending …\n"],["evaluate","Ackermann","Ackermann.html#method-i-evaluate","(m, n)","<p>The evaluate method is the main method used to calculate the final integer\nvalue of a given Ackermann …\n"],["evaluate_special_case","Ackermann","Ackermann.html#method-i-evaluate_special_case","(ackermann_index_array)","<p>The evaluate_special_case method returns a final integer solution for a\npair of Ackermann integer indexes …\n"],["get_pending_array","Ackermann","Ackermann.html#method-i-get_pending_array","(nested_array_dimension)","<p>The get_pending_array method returns the Ackermann indexes as an array\n[m,n] that corresponds to the …\n"],["is_infinity?","Ackermann","Ackermann.html#method-i-is_infinity-3F","(value)","<p>The is_infinity? method checks if a value is equal to Float::INFINITY\n<p><strong>Args</strong>       :\n\n<pre>- +value+ -&gt; value to ...</pre>\n"],["is_pending_result?","Ackermann","Ackermann.html#method-i-is_pending_result-3F","(nested_array_dimension)","<p>The is_pending_result method checks if a pair of Ackermann integer indexes\n(m,n) is  has been added to …\n"],["is_previous_result?","Ackermann","Ackermann.html#method-i-is_previous_result-3F","(ackermann_index_array)","<p>The is_previous_result? method returns a boolean upon checking if\n@@store_cases_results_hash variable …\n"],["is_special_case?","Ackermann","Ackermann.html#method-i-is_special_case-3F","(ackermann_index_array)","<p>The is_special_case? method checks if a pair of Ackermann integer indexes\n(m,n) has a previously calculated …\n"],["new","Ackermann","Ackermann.html#method-c-new","()","<p>The initialize method creates an instance hash to store pending solved\nackermann results called @pending_results_hash …\n"],["return_previous_result","Ackermann","Ackermann.html#method-i-return_previous_result","(ackermann_index_array)","<p>The return_previous_result method returns a previous solved saved result\nfrom the  @@store_cases_results_hash …\n"],["select_nested_array","Ackermann","Ackermann.html#method-i-select_nested_array","(nested_array, nested_array_dimension)","<p>The select_nested_array method uses a loop to select the inner most nested\narray containing only integers …\n"],["store_new_pending_result","Ackermann","Ackermann.html#method-i-store_new_pending_result","(ackermann_index_array, mark_dimension_to_save)","<p>The store_new_pending_result method is intended to store a new Ackermann\nindex array associated with …\n"]]}}