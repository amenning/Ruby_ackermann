<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Ackermann - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-ackermann_function">#ackermann_function</a>
    
    <li ><a href="#method-i-define_new_result">#define_new_result</a>
    
    <li ><a href="#method-i-evaluate">#evaluate</a>
    
    <li ><a href="#method-i-evaluate_special_case">#evaluate_special_case</a>
    
    <li ><a href="#method-i-get_pending_array">#get_pending_array</a>
    
    <li ><a href="#method-i-is_infinity-3F">#is_infinity?</a>
    
    <li ><a href="#method-i-is_pending_result-3F">#is_pending_result?</a>
    
    <li ><a href="#method-i-is_previous_result-3F">#is_previous_result?</a>
    
    <li ><a href="#method-i-is_special_case-3F">#is_special_case?</a>
    
    <li ><a href="#method-i-previous_results_hash">#previous_results_hash</a>
    
    <li ><a href="#method-i-return_previous_result">#return_previous_result</a>
    
    <li ><a href="#method-i-select_nested_array">#select_nested_array</a>
    
    <li ><a href="#method-i-store_new_pending_result">#store_new_pending_result</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Ackermann">
  <h1 id="class-Ackermann" class="class">
    class Ackermann
  </h1>

  <section class="description">
    
<p>The <a href="Ackermann.html">Ackermann</a> class contain custom methods to
implement the <a href="Ackermann.html">Ackermann</a> function. As defined
on wikipedia (<a
href="https://en.wikipedia.org/wiki/Ackermann_function">en.wikipedia.org/wiki/Ackermann_function</a>),
“the <a href="Ackermann.html">Ackermann</a> function is one of the simplest
and earliest discovered examples of a total computable function that is not
primitive recursive.”</p>

<p>This function is defined as follows:</p>

<p>A(m,n) =</p>
<ul><li>
<p>n+1                                  if m = 0</p>
</li><li>
<p>A(m-1, 1)                    if m &gt; 0 and n = 0</p>
</li><li>
<p>A(m-1, A(m, n-1))    if m &gt; 0 and n &gt; 0</p>
</li></ul>

<p>The methods below are also implemenented with the following constraints:</p>

<p>“Implement an Ackermann&#39;s function</p>
<ul><li>
<p>that does not recompute already-solved values</p>
</li><li>
<p>that optimizes low values of m as special cases</p>
</li><li>
<p>without using recursive function calls“</p>
</li></ul>

<p>This version avoids recursive function calls by using nested
multidimensional arrays. Each loop works on the inner most nested array as
the indexes for the <a href="Ackermann.html">Ackermann</a> function  until
the entire overall nested array collapses into a single Fixnum or Bignum
integer. For example:</p>
<ul><li>
<p>A(1,1) can be written as [1,1]</p>
</li></ul>

<p>This would be evaluated as follows:</p>
<ol><li>
<p>[1,1]      #This is defined to have nested array dimension of 0</p>
</li><li>
<p>[0,[1,0]] #Note this nested array is defined to have nested dimension of 1;
the working array [1,0] would be evaluated next</p>
</li><li>
<p>[0,[0,1]] #This still has a nested dimension of 1; the working array [0,1]
would be evaluated next</p>
</li><li>
<p>[0,2]</p>
</li><li>
<p>3</p>
</li></ol>

<p>Avoiding the use of recursive function calls is benefical as this prevents
SystemStackError of the stack level becoming too deep. In addition, the
avoidance of recrusive function calls could all this method to be modified
to allow for pausing a calculation and returning later</p>

<p>By saving previously calculated <a href="Ackermann.html">Ackermann</a>
results, this will optimize future attempts to calculate the same results
by only requiring a single hash lookup in a single iteration</p>

<p>This class also contains special cases when m is 0-3 and uses a simplified
formula when this is encountered; this also optimizes these <a
href="Ackermann.html">Ackermann</a> indexes and avoids unnecessary
iterations</p>
<dl class="rdoc-list note-list"><dt>Author
<dd>
<p>Carl Andrew Menning</p>
</dd><dt>Version
<dd>
<p>0.0.1</p>
</dd><dt>License
<dd>
<p>Distributed under the same terms as Ruby</p>
</dd></dl>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The initialize method creates an instance hash to store pending ackermann
solutions called @pending_results_hash</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p>no Arguments</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>new <a href="Ackermann.html">Ackermann</a> instance object</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
        <span class="ruby-comment">#Instance variable that stores pending Ackermann indexes [m,n] for new Ackermann(m,n) solutions</span>
        <span class="ruby-comment">#The key is the specified dimensional level of the overall Ackermann nested array being evaluated</span>
        <span class="ruby-comment">#The value is the associated Ackermann index array(s) [[m,n]]</span>
        <span class="ruby-ivar">@pending_results_hash</span> = {}
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-ackermann_function" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">ackermann_function</span><span
            class="method-args">(m, n)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-ackermann_function">#ackermann_function</a>
method is the brute force implementation of the ackermann function The
ackermann function is defined as A(m,n) =</p>
<ul><li>
<p>n+1                                 if m = 0</p>
</li><li>
<p>A(m-1, 1)                   if m &gt; 0 and n = 0</p>
</li><li>
<p>A(m-1, A(m, n-1))   if m &gt; 0 and n &gt; 0</p>
</li></ul>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>m</code> -&gt; first integer parameter for the ackermann function</p>
</li><li>
<p><code>n</code> -&gt; second integer parameter for the ackermann function</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>integer (n+1) if m = 0</p>
</li><li>
<p>array [m-1,1] if n = 0</p>
</li><li>
<p>nested array [m-1, [m, n-1]] if m &gt; 0 and n &gt; 0</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p><code>ArgumentError</code> -&gt; if input “m” or “n” is not of type Fixnum
or Bignum</p>
</li><li>
<p><code>RangeError</code> -&gt; if input “m” or “n” is not &gt;= 0</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="ackermann_function-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ackermann_function</span>(<span class="ruby-identifier">m</span>, <span class="ruby-identifier">n</span>)
        <span class="ruby-comment"># Check if m and n are of type Fixnum or Bignum, otherwise raise ArgumentError</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>((<span class="ruby-identifier">m</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Fixnum</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Bignum</span>)) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">n</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Fixnum</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Bignum</span>)))
                <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;Both input parameters (m and n) must be of type Fixnum or Bignum&quot;</span>
        <span class="ruby-comment"># Check if m and n are both equal to or greater than 0, otherwise raise RangeError</span>
        <span class="ruby-keyword">elsif</span>(<span class="ruby-identifier">m</span><span class="ruby-operator">&lt;</span><span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">n</span><span class="ruby-operator">&lt;</span><span class="ruby-value">0</span>)
                <span class="ruby-identifier">raise</span> <span class="ruby-constant">RangeError</span>, <span class="ruby-string">&quot;Both input paramters (m and n) must be equal to or greater than 0&quot;</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
                <span class="ruby-keyword">return</span> <span class="ruby-identifier">n</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
                <span class="ruby-keyword">return</span> [<span class="ruby-identifier">m</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>,<span class="ruby-value">1</span>]
        <span class="ruby-keyword">else</span>
                <span class="ruby-keyword">return</span> [<span class="ruby-identifier">m</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>, [<span class="ruby-identifier">m</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>]]
        <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-define_new_result" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">define_new_result</span><span
            class="method-args">(nested_array_dimension, new_result)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-define_new_result">#define_new_result</a>
method is intended to store a final new integer result for a previously
pending ackerman index array.  It deletes the ackerman index array from the
pending @pending_results_hash  instance variable and stores the new result
in the class variable @@previous_results_hash</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>nested_array_dimension</code> -&gt; dimension of the overall <a
href="Ackermann.html">Ackermann</a> nested array</p>
</li><li>
<p><code>new_result</code> -&gt; final integer value to be associated with <a
href="Ackermann.html">Ackermann</a> index array</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>true if no error is encountered</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="define_new_result-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">define_new_result</span>(<span class="ruby-identifier">nested_array_dimension</span>, <span class="ruby-identifier">new_result</span>)
        <span class="ruby-ivar">@pending_results_hash</span>[<span class="ruby-identifier">nested_array_dimension</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">@@previous_results_hash</span>[[<span class="ruby-identifier">m</span>,<span class="ruby-identifier">n</span>]] = <span class="ruby-identifier">new_result</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-ivar">@pending_results_hash</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">nested_array_dimension</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-evaluate" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">evaluate</span><span
            class="method-args">(m, n)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The evaluate method is the main method used to calculate the final integer
value of a given <a href="Ackermann.html">Ackermann</a> index. For example,
A(1,1) would result in 3.</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>m</code> -&gt; first integer parameter for the ackermann function</p>
</li><li>
<p><code>n</code> -&gt; second integer parameter for the ackermann function</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>final integer solution to <a href="Ackermann.html">Ackermann</a> function</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>RangeError if integer solution grows too large</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="evaluate-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">evaluate</span>(<span class="ruby-identifier">m</span>, <span class="ruby-identifier">n</span>)
        <span class="ruby-comment">#Set dimensional level of nested array to 1</span>
        <span class="ruby-identifier">dimension_of_nested_array</span> = <span class="ruby-value">0</span>
        <span class="ruby-comment">#Create overall total array to be monitored</span>
        <span class="ruby-identifier">total_array</span> = [<span class="ruby-identifier">m</span>, <span class="ruby-identifier">n</span>]
        <span class="ruby-comment">#While dimension of nested arrays is &gt;= 0 (i.e. not an integer), continue loop</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">dimension_of_nested_array</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-keyword">do</span>
                <span class="ruby-comment"># 1. Set working array (Ackerman indexes) to be the inner most nested array </span>
                <span class="ruby-identifier">working_array</span> = <span class="ruby-identifier">select_nested_array</span>(<span class="ruby-identifier">total_array</span>, <span class="ruby-identifier">dimension_of_nested_array</span>)
                <span class="ruby-comment"># 2. Check if current Ackermann indexes have been solved before; if not, mark indexes as pending final integer result</span>
                <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">is_previous_result?</span>(<span class="ruby-identifier">working_array</span>))
                        <span class="ruby-comment">#Store new result in pending_results_hash using current dimension of nested array as key and current Ackermann indexes as the value</span>
                        <span class="ruby-identifier">store_new_pending_result</span>([<span class="ruby-identifier">working_array</span>[<span class="ruby-value">0</span>],<span class="ruby-identifier">working_array</span>[<span class="ruby-value">1</span>]], <span class="ruby-identifier">dimension_of_nested_array</span>)
                <span class="ruby-keyword">end</span>
                
                <span class="ruby-comment"># 3. Calculate result using the following order</span>
                <span class="ruby-comment"># 3a. Return previously calculated result if stored in @@previous_results_hash</span>
                <span class="ruby-keyword">if</span> (<span class="ruby-identifier">is_previous_result?</span>(<span class="ruby-identifier">working_array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">return_previous_result</span>(<span class="ruby-identifier">working_array</span>)<span class="ruby-operator">!=</span><span class="ruby-keyword">nil</span>)
                        <span class="ruby-identifier">return_result</span> = <span class="ruby-identifier">return_previous_result</span>(<span class="ruby-identifier">working_array</span>)
                <span class="ruby-comment"># 3b. Return result if part of special cases where m is equal to 0-3</span>
                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">is_special_case?</span>(<span class="ruby-identifier">working_array</span>)
                        <span class="ruby-identifier">return_result</span> = <span class="ruby-identifier">evaluate_special_case</span>(<span class="ruby-identifier">working_array</span>)
                <span class="ruby-comment"># 3c. Return result using brute force Ackermann function</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-identifier">return_result</span> = <span class="ruby-identifier">ackermann_function</span>(<span class="ruby-identifier">working_array</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">working_array</span>[<span class="ruby-value">1</span>])
                <span class="ruby-keyword">end</span>
                
                <span class="ruby-comment"># 4. Check if result has become too large and has been defined as &quot;infinity&quot; to prevent infinite loop</span>
                <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_infinity?</span>(<span class="ruby-identifier">return_result</span>)
                        <span class="ruby-comment"># Clear pending results to clean up current iteration</span>
                        <span class="ruby-ivar">@pending_results_hash</span>.<span class="ruby-identifier">clear</span>
                        <span class="ruby-comment"># Raise RangeError to warn user</span>
                        <span class="ruby-identifier">raise</span> <span class="ruby-constant">RangeError</span>, <span class="ruby-string">&quot;Number became too large&quot;</span>
                <span class="ruby-keyword">end</span>
                
                <span class="ruby-comment"># 5. Check if result is an array and/or a nested array, or has collapsed to an integer</span>
                <span class="ruby-keyword">if</span> <span class="ruby-identifier">return_result</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>)
                        <span class="ruby-comment">#If result has created a further nested array, increase dimension of nested array</span>
                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">return_result</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>)
                                <span class="ruby-identifier">dimension_of_nested_array</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
                        <span class="ruby-keyword">end</span>
                        <span class="ruby-comment">#Adjust working array for next loop</span>
                        <span class="ruby-identifier">working_array</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">return_result</span>[<span class="ruby-value">0</span>]
                        <span class="ruby-identifier">working_array</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">return_result</span>[<span class="ruby-value">1</span>]
                
                <span class="ruby-comment"># If return result has collapsed to an integer value, store new result if listed as pending and adjust dimension of overall nested array</span>
                <span class="ruby-keyword">else</span>                         
                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_pending_result?</span>(<span class="ruby-identifier">dimension_of_nested_array</span>)
                                <span class="ruby-identifier">pending_result_array</span> = <span class="ruby-identifier">get_pending_array</span>(<span class="ruby-identifier">dimension_of_nested_array</span>)
                                <span class="ruby-identifier">define_new_result</span>(<span class="ruby-identifier">dimension_of_nested_array</span>, <span class="ruby-identifier">return_result</span>)
                        <span class="ruby-keyword">end</span>
                        
                        <span class="ruby-identifier">dimension_of_nested_array</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
                        
                        <span class="ruby-comment">#Check if collapsed integer result is contained within a higher level array or if all arrays have collapsed to a single integer</span>
                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">dimension_of_nested_array</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> 
                                <span class="ruby-comment">#Adjust working array one level up from current position to select outer array containing the current solution</span>
                                <span class="ruby-identifier">working_array</span> = <span class="ruby-identifier">select_nested_array</span>(<span class="ruby-identifier">total_array</span>, <span class="ruby-identifier">dimension_of_nested_array</span>)
                                <span class="ruby-identifier">working_array</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">return_result</span>
                        <span class="ruby-keyword">else</span>
                                <span class="ruby-comment">#Assign final overall collapsed result to local variable answer</span>
                                <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">return_result</span>
                        <span class="ruby-keyword">end</span>
                <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># Return final integer value for given overal Ackermann indexes</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-evaluate_special_case" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">evaluate_special_case</span><span
            class="method-args">(ackermann_index_array)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-evaluate_special_case">#evaluate_special_case</a>
method returns a final integer solution for a pair of <a
href="Ackermann.html">Ackermann</a> integer indexes (m,n) based on the
evaluted equation supplied by the @@special_cases_hash</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>ackermann_index_array</code> -&gt; array containing ackermann integer
indexes [m,n]</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>integer value for evaluated special cases</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="evaluate_special_case-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">evaluate_special_case</span>(<span class="ruby-identifier">ackermann_index_array</span>)
        <span class="ruby-comment"># assigned first local Ackermann index m</span>
        <span class="ruby-identifier">m</span> = <span class="ruby-identifier">ackermann_index_array</span>[<span class="ruby-value">0</span>]
        <span class="ruby-comment"># assigned first local Ackermann index n</span>
        <span class="ruby-identifier">n</span> = <span class="ruby-identifier">ackermann_index_array</span>[<span class="ruby-value">1</span>]
        <span class="ruby-comment"># Obtain string representation of simpilified solutions for special cases</span>
        <span class="ruby-identifier">special_case_function</span> = <span class="ruby-identifier">@@special_cases_hash</span>[<span class="ruby-identifier">m</span>]
        <span class="ruby-comment"># Evaluate string representation using local variable n and return integer value solution</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">eval</span>(<span class="ruby-identifier">special_case_function</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-get_pending_array" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_pending_array</span><span
            class="method-args">(nested_array_dimension)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-get_pending_array">#get_pending_array</a>
method returns the <a href="Ackermann.html">Ackermann</a> indexes as an
array [m,n] that corresponds to the assigned pending nested array dimension
of the overall <a href="Ackermann.html">Ackermann</a> nested array</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>nested_array_dimension</code> -&gt; dimension of the overall <a
href="Ackermann.html">Ackermann</a> nested array</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>array with <a href="Ackermann.html">Ackermann</a> indexes [m,n]</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="get_pending_array-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 265</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_pending_array</span>(<span class="ruby-identifier">nested_array_dimension</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-ivar">@pending_results_hash</span>[<span class="ruby-identifier">nested_array_dimension</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-is_infinity-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_infinity?</span><span
            class="method-args">(value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The is_infinity? method checks if a value is equal to Float::INFINITY</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>value</code> -&gt; value to check if equal to Float::INFINITY</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>true if value is equal to Float::INFINITY</p>
</li><li>
<p>false if value is not equal to Float::INFINITY</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="is_infinity-3F-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 346</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_infinity?</span>(<span class="ruby-identifier">value</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Float</span><span class="ruby-operator">::</span><span class="ruby-constant">INFINITY</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-is_pending_result-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_pending_result?</span><span
            class="method-args">(nested_array_dimension)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The is_pending_result method checks if a pair of <a
href="Ackermann.html">Ackermann</a> integer indexes (m,n) has been added to
the instance variable @pending_results_hash</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>nested_array_dimension</code> -&gt; dimension of the overall <a
href="Ackermann.html">Ackermann</a> nested array</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>true if instance variable @pending_results_hash contains the supplied
nested array dimension as a key</p>
</li><li>
<p>false if instance variable @pending_results_hash does not contain the
supplied nested array dimension as a key</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="is_pending_result-3F-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_pending_result?</span>(<span class="ruby-identifier">nested_array_dimension</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-ivar">@pending_results_hash</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">nested_array_dimension</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-is_previous_result-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_previous_result?</span><span
            class="method-args">(ackermann_index_array)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The is_previous_result? method returns a boolean upon checking if
@@previous_results_hash variable contains a key based on an array of
ackermann indexes</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>ackermann_index_array</code> -&gt; array containing ackermann integer
indexes [m,n]</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>true if ackermann index array key is found in class variable
@@previous_results_hash</p>
</li><li>
<p>false if ackermann index array key is not found</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="is_previous_result-3F-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_previous_result?</span>(<span class="ruby-identifier">ackermann_index_array</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">@@previous_results_hash</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">ackermann_index_array</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-is_special_case-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_special_case?</span><span
            class="method-args">(ackermann_index_array)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The is_special_case? method checks if a pair of <a
href="Ackermann.html">Ackermann</a> integer indexes (m,n) falls within the 
special case where m is a key 0-3 in the class variable
@@special_cases_hash</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>ackermann_index_array</code> -&gt; array containing ackermann integer
indexes [m,n]</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>true if class variable @@special_cases_hash contains the supplied <a
href="Ackermann.html">Ackermann</a> m index</p>
</li><li>
<p>false otherwise</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="is_special_case-3F-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_special_case?</span>(<span class="ruby-identifier">ackermann_index_array</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">@@special_cases_hash</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">ackermann_index_array</span>[<span class="ruby-value">0</span>])
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-previous_results_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">previous_results_hash</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-previous_results_hash">#previous_results_hash</a>
method allows access to the class variable of the same name</p>
          
          

          
          <div class="method-source-code" id="previous_results_hash-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 351</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">previous_results_hash</span>
        <span class="ruby-identifier">@@previous_results_hash</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-return_previous_result" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">return_previous_result</span><span
            class="method-args">(ackermann_index_array)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-return_previous_result">#return_previous_result</a>
method returns a previously solved saved result from the 
@@previous_results_hash variable based on an array of ackermann indexes</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>ackermann_index_array</code> -&gt; array containing ackermann integer
indexes [m,n]</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>stored integer value if ackermann index array key is found in class
variable @@previous_results_hash</p>
</li><li>
<p>nil if ackermann index array key is not found</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="return_previous_result-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 333</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">return_previous_result</span>(<span class="ruby-identifier">ackermann_index_array</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">@@previous_results_hash</span>[<span class="ruby-identifier">ackermann_index_array</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-select_nested_array" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">select_nested_array</span><span
            class="method-args">(nested_array, nested_array_dimension)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-select_nested_array">#select_nested_array</a>
method uses a loop to select the inner most nested array containing only
integers from the supplied nested array</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>nested_array</code> -&gt; array containing variable nested arrays</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>inner most array [m,n] as specified by the desired nested_array_dimension</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="select_nested_array-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_nested_array</span>(<span class="ruby-identifier">nested_array</span>, <span class="ruby-identifier">nested_array_dimension</span>)
        <span class="ruby-identifier">return_array_reference</span> = <span class="ruby-identifier">nested_array</span>
        <span class="ruby-comment">#Use for loop to iterate inwards on the 2nd element of each nested array until specified nested array is reached</span>
        <span class="ruby-keyword">for</span> <span class="ruby-identifier">dimension</span> <span class="ruby-keyword">in</span> <span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">nested_array_dimension</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>) <span class="ruby-keyword">do</span>
                <span class="ruby-identifier">return_array_reference</span> = <span class="ruby-identifier">return_array_reference</span>[<span class="ruby-value">1</span>]
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment">#Return nested array [m,n]</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">return_array_reference</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-store_new_pending_result" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">store_new_pending_result</span><span
            class="method-args">(ackermann_index_array, mark_dimension_to_save)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The <a
href="Ackermann.html#method-i-store_new_pending_result">#store_new_pending_result</a>
method is intended to store a new <a href="Ackermann.html">Ackermann</a>
index array associated with a given dimensional level of the overall <a
href="Ackermann.html">Ackermann</a> nested array being evaluated.  This
will store the new ackermann index array [m,n] as a value associated with
the key being the specified nested array dimension in the instance variable
@pending_results_hash.</p>

<p><strong>Args</strong>          :</p>
<ul><li>
<p><code>ackermann_index_array</code> -&gt; array containing ackermann integer
indexes [m,n]</p>
</li><li>
<p><code>mark_dimension_to_save</code> -&gt; specified dimensonal level of
overall <a href="Ackermann.html">Ackermann</a> nested array being evaluated</p>
</li></ul>

<p><strong>Returns</strong> :</p>
<ul><li>
<p>true if no error is encountered</p>
</li></ul>

<p><strong>Raises</strong>  :</p>
<ul><li>
<p>This method contains no additional error checks</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="store_new_pending_result-source">
            <pre><span class="ruby-comment"># File ackermann.rb, line 281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">store_new_pending_result</span>(<span class="ruby-identifier">ackermann_index_array</span>, <span class="ruby-identifier">mark_dimension_to_save</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-ivar">@pending_results_hash</span>[<span class="ruby-identifier">mark_dimension_to_save</span>] <span class="ruby-operator">!=</span> <span class="ruby-keyword">nil</span>
                <span class="ruby-ivar">@pending_results_hash</span>[<span class="ruby-identifier">mark_dimension_to_save</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ackermann_index_array</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-ivar">@pending_results_hash</span>[<span class="ruby-identifier">mark_dimension_to_save</span>] = [<span class="ruby-identifier">ackermann_index_array</span>]
        <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

